// Copyright 2020 The MediaPipe Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "mediapipe/framework/calculator_context.h"
#include "mediapipe/framework/calculator_framework.h"
#include "mediapipe/framework/formats/detection.pb.h"
#include "mediapipe/framework/formats/location.h"
#include "mediapipe/framework/port/rectangle.h"
#include "mediapipe/framework/port/status.h"
#include "mediapipe/modules/objectron/calculators/annotation_data.pb.h"

namespace mediapipe {

namespace {

constexpr char kDetectionsTag[] = "DETECTIONS";
constexpr char kFrameAnnotationTag[] = "ANNOTATIONS";

using Detections = std::vector<Detection>;

} // namespace

// Assigns annotation_data the same ids as the corresponding detections,
//  which are vectors of the same size. For context, the annotation_data is
//  generated by running 3D detectors on 2D crops from detections, so there
//  should be a one-to-one correspondence determined by the order of the two
//  vectors (iterables).
// node {
//   calculator: "AssociationDetectionAnnotationByOrderCalculator"
//   input_stream: "DETECTIONS:detections"
//   input_stream: "ANNOTATIONS:annotations"
//   output_stream: "ANNOTATIONS:annotations_with_id"
// }
class AssociationDetectionAnnotationByOrderCalculator : public CalculatorBase {
public:
  static absl::Status GetContract(CalculatorContract *cc);
  // absl::Status Open(CalculatorContext *cc) override;
  absl::Status Process(CalculatorContext *cc) override;
};
REGISTER_CALCULATOR(AssociationDetectionAnnotationByOrderCalculator);

absl::Status AssociationDetectionAnnotationByOrderCalculator::GetContract(
    CalculatorContract *cc) {
  RET_CHECK(!cc->Inputs().GetTags().empty());
  RET_CHECK(!cc->Outputs().GetTags().empty());

  cc->Inputs().Tag(kDetectionsTag).Set<Detections>();
  cc->Inputs().Tag(kFrameAnnotationTag).Set<FrameAnnotation>();
  cc->Outputs().Tag(kFrameAnnotationTag).Set<FrameAnnotation>();
  return absl::OkStatus();
}

absl::Status AssociationDetectionAnnotationByOrderCalculator::Process(
    CalculatorContext *cc) {
  std::cout << "from association_detection_annotation_by_order_calculator"
            << std::endl;
  Detections detections;
  if (cc->Inputs().HasTag(kDetectionsTag)) {
    detections = cc->Inputs().Tag(kDetectionsTag).Get<Detections>();
  }
  FrameAnnotation frameAnnotations;
  if (cc->Inputs().HasTag(kFrameAnnotationTag)) {
    frameAnnotations =
        cc->Inputs().Tag(kFrameAnnotationTag).Get<FrameAnnotation>();
  }

  // deep copy
  std::unique_ptr<FrameAnnotation> frameAnnotationsWithId =
      absl::make_unique<FrameAnnotation>();
  *(frameAnnotationsWithId.get()) = frameAnnotations;

  std::cout << "   detections.size() " << detections.size()
            << "   frameAnnotationsWithId->annotations.size() "
            << frameAnnotationsWithId->annotations_size() << std::endl;
  RET_CHECK(detections.size() == frameAnnotationsWithId->annotations_size());

  for (int i = 0; i < detections.size(); ++i) {
    int object_id = detections[i].detection_id();
    frameAnnotationsWithId->mutable_annotations(i)->set_object_id(object_id);
  }
  if (cc->Outputs().HasTag(kFrameAnnotationTag)) {
    cc->Outputs()
        .Tag(kFrameAnnotationTag)
        .Add(frameAnnotationsWithId.release(), cc->InputTimestamp());
  }

  return absl::OkStatus();
}

} // namespace mediapipe
